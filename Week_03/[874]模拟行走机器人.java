//æœºå™¨äººåœ¨ä¸€ä¸ªæ— é™å¤§å°çš„ XY ç½‘æ ¼å¹³é¢ä¸Šè¡Œèµ°ï¼Œä»ç‚¹ (0, 0) å¤„å¼€å§‹å‡ºå‘ï¼Œé¢å‘åŒ—æ–¹ã€‚è¯¥æœºå™¨äººå¯ä»¥æ¥æ”¶ä»¥ä¸‹ä¸‰ç§ç±»å‹çš„å‘½ä»¤ commands ï¼š 
//
// 
// -2 ï¼šå‘å·¦è½¬ 90 åº¦ 
// -1 ï¼šå‘å³è½¬ 90 åº¦ 
// 1 <= x <= 9 ï¼šå‘å‰ç§»åŠ¨ x ä¸ªå•ä½é•¿åº¦ 
// 
//
// åœ¨ç½‘æ ¼ä¸Šæœ‰ä¸€äº›æ ¼å­è¢«è§†ä¸ºéšœç¢ç‰© obstacles ã€‚ç¬¬ i ä¸ªéšœç¢ç‰©ä½äºç½‘æ ¼ç‚¹ obstacles[i] = (xi, yi) ã€‚ 
//
// æœºå™¨äººæ— æ³•èµ°åˆ°éšœç¢ç‰©ä¸Šï¼Œå®ƒå°†ä¼šåœç•™åœ¨éšœç¢ç‰©çš„å‰ä¸€ä¸ªç½‘æ ¼æ–¹å—ä¸Šï¼Œä½†ä»ç„¶å¯ä»¥ç»§ç»­å°è¯•è¿›è¡Œè¯¥è·¯çº¿çš„å…¶ä½™éƒ¨åˆ†ã€‚ 
//
// è¿”å›ä»åŸç‚¹åˆ°æœºå™¨äººæ‰€æœ‰ç»è¿‡çš„è·¯å¾„ç‚¹ï¼ˆåæ ‡ä¸ºæ•´æ•°ï¼‰çš„æœ€å¤§æ¬§å¼è·ç¦»çš„å¹³æ–¹ã€‚ï¼ˆå³ï¼Œå¦‚æœè·ç¦»ä¸º 5 ï¼Œåˆ™è¿”å› 25 ï¼‰ 
//
// 
// 
// 
// 
// 
// 
//
// 
// æ³¨æ„ï¼š 
//
// 
// åŒ—è¡¨ç¤º +Y æ–¹å‘ã€‚ 
// ä¸œè¡¨ç¤º +X æ–¹å‘ã€‚ 
// å—è¡¨ç¤º -Y æ–¹å‘ã€‚ 
// è¥¿è¡¨ç¤º -X æ–¹å‘ã€‚ 
// 
// 
// 
// 
// 
//
// 
//
// ç¤ºä¾‹ 1ï¼š 
//
// 
//è¾“å…¥ï¼šcommands = [4,-1,3], obstacles = []
//è¾“å‡ºï¼š25
//è§£é‡Šï¼š
//æœºå™¨äººå¼€å§‹ä½äº (0, 0)ï¼š
//1. å‘åŒ—ç§»åŠ¨ 4 ä¸ªå•ä½ï¼Œåˆ°è¾¾ (0, 4)
//2. å³è½¬
//3. å‘ä¸œç§»åŠ¨ 3 ä¸ªå•ä½ï¼Œåˆ°è¾¾ (3, 4)
//è·ç¦»åŸç‚¹æœ€è¿œçš„æ˜¯ (3, 4) ï¼Œè·ç¦»ä¸º 32 + 42 = 25 
//
// ç¤ºä¾‹ 2ï¼š 
//
// 
//è¾“å…¥ï¼šcommands = [4,-1,4,-2,4], obstacles = [[2,4]]
//è¾“å‡ºï¼š65
//è§£é‡Šï¼šæœºå™¨äººå¼€å§‹ä½äº (0, 0)ï¼š
//1. å‘åŒ—ç§»åŠ¨ 4 ä¸ªå•ä½ï¼Œåˆ°è¾¾ (0, 4)
//2. å³è½¬
//3. å‘ä¸œç§»åŠ¨ 1 ä¸ªå•ä½ï¼Œç„¶åè¢«ä½äº (2, 4) çš„éšœç¢ç‰©é˜»æŒ¡ï¼Œæœºå™¨äººåœåœ¨ (1, 4)
//4. å·¦è½¬
//5. å‘åŒ—èµ° 4 ä¸ªå•ä½ï¼Œåˆ°è¾¾ (1, 8)
//è·ç¦»åŸç‚¹æœ€è¿œçš„æ˜¯ (1, 8) ï¼Œè·ç¦»ä¸º 12 + 82 = 65 
//
// 
//
// æç¤ºï¼š 
//
// 
// 1 <= commands.length <= 104 
// commands[i] is one of the values in the list [-2,-1,1,2,3,4,5,6,7,8,9]. 
// 0 <= obstacles.length <= 104 
// -3 * 104 <= xi, yi <= 3 * 104 
// ç­”æ¡ˆä¿è¯å°äº 231 
// 
// Related Topics è´ªå¿ƒç®—æ³• 
// ğŸ‘ 121 ğŸ‘ 0


//leetcode submit region begin(Prohibit modification and deletion)
//Round1
/*
* 1.å–å¾—å½“å‰æœºå™¨äººçš„æ–¹å‘ï¼Œå¼€å§‹ç§»åŠ¨
* 2.æ¯ç§»åŠ¨ä¸€æ­¥å‰åˆ¤æ–­è¯¥ä½ç½®æ˜¯å¦ä¸ºéšœç¢ç‰©ï¼Œå¦‚æœå­˜åœ¨éšœç¢ç‰©ï¼Œç»“æŸå½“å‰è·¯å¾„çš„ç§»åŠ¨
* 3.è‹¥æ— éšœç¢ç‰©ï¼Œç§»åŠ¨ï¼Œæ›´æ–°å½“å‰ä½ç½®ï¼Œç„¶åä¸å½“å‰çš„æœ€è¿œè·ç¦»æ¯”è¾ƒï¼Œå¦‚æœå¤§äºæœ€è¿œè·ç¦»åˆ™æ›´æ–°æœ€è¿œè·ç¦»ã€‚
* 4.ç§»åŠ¨å®Œæ¯•åå–å¾—æœ€è¿œè·ç¦»
* */
class Solution {
    public int robotSim(int[] commands, int[][] obstacles) {
        //directionè¡¨å½“å‰æœå‘ï¼Œ0123 è¡¨ åŒ—ä¸œå—è¥¿
        int ans = 0,direction = 0,x = 0,y = 0;
        //æ¯ä¸ªæœå‘ä¸Šçš„æ•°æ®å˜åŒ–ï¼Œæ¯”å¦‚æœåŒ—æ—¶å–Direction[0]  ->   {0,1}
        //é‚£ä¹ˆxè½´çš„å˜åŒ–ä¸ºx+0ï¼Œyè½´å˜åŒ–ä¸ºy+1;
        int[][] Direction = {{0,1},{1,0},{0,-1},{-1,0}};

        HashSet<String> set = new HashSet<>();
        //å°†æ‰€æœ‰éšœç¢ç‰©åæ ‡ç»„åˆæˆå­—ç¬¦ä¸²å­˜å…¥setä¸­æ–¹ä¾¿æŸ¥è¯¢
        for (int[] arr : obstacles){
            set.add(arr[0]+","+arr[1]);
        }
        for (int com : commands){
            //å®šä¹‰ä¸‹ä¸€æ­¥çš„åæ ‡
            int next_x = 0,next_y = 0;
            //å½“å‘½ä»¤ä¸ºå‰è¿›ï¼Œå¼€å§‹ç§»åŠ¨
            if (com >= 0 ){
                for(int i = 0; i < com; i++){
                    //å–å¾—ä¸‹ä¸€æ­¥çš„åæ ‡
                    next_x = x + Direction[direction][0];
                    next_y = y + Direction[direction][1];
                    //è‹¥ä¸‹ä¸€æ­¥æœ‰éšœç¢ç‰©ï¼Œç»“æŸå½“å‰å‘½ä»¤ï¼Œè·³è‡³ä¸‹ä¸€å‘½ä»¤
                    if(set.contains(next_x+","+next_y)) {
                        break;
                    }
                    //å¦åˆ™æ›´æ–°åæ ‡ä¸æœ€è¿œè·ç¦»
                    x = next_x;
                    y = next_y;
                    ans = Math.max(ans, x*x + y*y);
                }
            }else{
                //æ”¹å˜æœå‘
                direction = com == -1 ? (direction + 1) % 4 : (direction + 3) % 4;
            }
        }
        return ans;
    }
}

// å®˜æ–¹ä¼˜åŒ–åœ¨äºå°†Set çš„æ•°æ®è¿›è¡Œäº†ç¼–ç å¤„ç†
/*class Solution {
    public int robotSim(int[] commands, int[][] obstacles) {
        int[] dx = new int[]{0, 1, 0, -1};
        int[] dy = new int[]{1, 0, -1, 0};
        int x = 0, y = 0, di = 0;

        // Encode obstacles (x, y) as (x+30000) * (2^16) + (y+30000)
        Set<Long> obstacleSet = new HashSet();
        for (int[] obstacle: obstacles) {
            long ox = (long) obstacle[0] + 30000;
            long oy = (long) obstacle[1] + 30000;
            obstacleSet.add((ox << 16) + oy);
        }

        int ans = 0;
        for (int cmd: commands) {
            if (cmd == -2)  //left
                di = (di + 3) % 4;
            else if (cmd == -1)  //right
                di = (di + 1) % 4;
            else {
                for (int k = 0; k < cmd; ++k) {
                    int nx = x + dx[di];
                    int ny = y + dy[di];
                    long code = (((long) nx + 30000) << 16) + ((long) ny + 30000);
                    if (!obstacleSet.contains(code)) {
                        x = nx;
                        y = ny;
                        ans = Math.max(ans, x*x + y*y);
                    }
                }
            }
        }

        return ans;
    }
}*/
//leetcode submit region end(Prohibit modification and deletion)
